/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package InterfazGrafica; 

import java.awt.Label;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import static java.lang.Thread.sleep;
import java.net.InetAddress;
import java.net.InetSocketAddress;
import java.net.Socket;
import java.net.SocketAddress;
import java.net.SocketTimeoutException;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 *
 * @author Juan Martin
 */
public class QLearning extends javax.swing.JFrame {

    //Factor de aprendizaje
    public static final double BETA = 0.9;
    //Tasa de descuento
    public static final double GAMMA = 0.5;
    //Numero de episodios
    public static final int NUMERO_EPISODIOS = 40000;
    
    static final int CANT_ESTADOS = 27;
    
    static final int CANT_ACCIONES = 9;
    
    static final int ACCION_IZQ_M30_DER_M30 = 0;
    static final int ACCION_IZQ_M30_DER_35 = 1;
    static final int ACCION_IZQ_M30_DER_50 = 2;
    static final int ACCION_IZQ_35_DER_M30 = 3;
    static final int ACCION_IZQ_35_DER_35 = 4;
    static final int ACCION_IZQ_35_DER_50 = 5;
    static final int ACCION_IZQ_50_DER_M30 = 6;
    static final int ACCION_IZQ_50_DER_35 = 7;
    static final int ACCION_IZQ_50_DER_50 = 8;
    // No es una de las acciones que realiza khepera
    static final int ACCION_LEER_SENSORES = 9;   
    //Valor de sensor considerado como posible choque
    static final int VALOR_CHOQUE = 500;
    static final int VALOR_APROXIMACION = 300;
            
    double[][] tabla_q = new double [CANT_ESTADOS][CANT_ACCIONES];
    
    double epsilon = 0.9;
    
    float auxiliar = 0, auxiliar2 = 0;
    
    float pesos[];
     
    
    
    /**
     * Creates new form QLearning
     */
    public QLearning() {
        this.pesos = new float[]{1.2f, 1.3f, 1.5f, 1.6f, 1.1f, 1.2f, 1.6f, 1.6f};
        initComponents();
        
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        panelPrincipal = new javax.swing.JPanel();
        qTableLabel = new javax.swing.JLabel();
        jScrollPane1 = new javax.swing.JScrollPane();
        qTable = new javax.swing.JTable();
        jLabel1 = new javax.swing.JLabel();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("Q Learning");

        qTableLabel.setText("Q Table");

        qTable.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {
                {null, null, null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null, null, null}
            },
            new String [] {
                "M30 - M30", "M30 - 35", "M30 - 50", "35 - M30", "35 - 35", "35 - 50", "50 - M30", "50 - 35", "50 - 50", "Estado (atras, der, izq)"
            }
        ) {
            Class[] types = new Class [] {
                java.lang.Double.class, java.lang.Double.class, java.lang.Double.class, java.lang.Double.class, java.lang.Double.class, java.lang.Double.class, java.lang.Double.class, java.lang.Double.class, java.lang.Double.class, java.lang.String.class
            };
            boolean[] canEdit = new boolean [] {
                false, false, false, false, false, false, false, false, false, false
            };

            public Class getColumnClass(int columnIndex) {
                return types [columnIndex];
            }

            public boolean isCellEditable(int rowIndex, int columnIndex) {
                return canEdit [columnIndex];
            }
        });
        jScrollPane1.setViewportView(qTable);

        jLabel1.setText("jLabel1");

        javax.swing.GroupLayout panelPrincipalLayout = new javax.swing.GroupLayout(panelPrincipal);
        panelPrincipal.setLayout(panelPrincipalLayout);
        panelPrincipalLayout.setHorizontalGroup(
            panelPrincipalLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(panelPrincipalLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(panelPrincipalLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(panelPrincipalLayout.createSequentialGroup()
                        .addComponent(qTableLabel)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(jLabel1)
                        .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, panelPrincipalLayout.createSequentialGroup()
                        .addGap(15, 15, 15)
                        .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 1230, Short.MAX_VALUE))))
        );
        panelPrincipalLayout.setVerticalGroup(
            panelPrincipalLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(panelPrincipalLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(panelPrincipalLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(qTableLabel)
                    .addComponent(jLabel1))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 563, Short.MAX_VALUE))
        );

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(panelPrincipal, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(panelPrincipal, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(QLearning.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(QLearning.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(QLearning.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(QLearning.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        final QLearning ql =  new QLearning();
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                ql.setVisible(true);
            }
        });
        ql. ejecutar();
    }

    public void ejecutar() {
        
        int iteracion = 1;

        String testServerName = "localhost";
        int port = 6800;
        Socket socket = null;
        try {
            // open a socket


            double q_actual;
            double q_max;
            double q_nuevo;
            //Posicion de estado en la tabla Q
            int pos_estado;
            int nuevo_pos_estado;
            int accion;
            double recompensa;

            inicializarValoresQ(0.0);
            
            socket = openSocket(testServerName, port);
            
            //Recuperar estado desde robot
            pos_estado = this.getEstado(socket);

            while (iteracion != NUMERO_EPISODIOS) {
                accion = seleccionarAccion(pos_estado);

                socket = openSocket(testServerName, port);
                //Ejecuta accion 
                ejecutarAccion(accion, socket);

                socket = openSocket(testServerName, port);

                //Nuevo estado luego de ejecutar la accion
                nuevo_pos_estado = this.getEstado(socket);

                //Calcula la recompensa para el nuevo par estado-accion
                recompensa = getRecompensa(pos_estado, nuevo_pos_estado);


                q_actual = tabla_q[pos_estado][accion];

                q_max = getMaxQ(nuevo_pos_estado);

                // Calculate new Value for Q
                q_nuevo = q_actual + BETA * (recompensa + GAMMA * q_max - q_actual);

                tabla_q[pos_estado][accion] = q_nuevo;
                qTable.setValueAt(q_nuevo, pos_estado, accion);
                jLabel1.setText(""+epsilon);
                // Set state to the new state.
                pos_estado = nuevo_pos_estado;

                iteracion++;
                if (iteracion % 2000 == 0){
                    if(epsilon > 0.2){
                         epsilon -= 0.1;
                    }
                }
            }

            // close the socket, and we're done
            socket.close();
        } catch (Exception e) {
            e.printStackTrace();
        }



    } // end ejecutar 

    //Inicializar la matriz de valores Q
    public void inicializarValoresQ(double valorInicial) {
        for (int i = 0; i < CANT_ESTADOS; i++) {
            for (int j = 0; j < CANT_ACCIONES; j++) {
                tabla_q[i][j] = valorInicial;
                qTable.setValueAt(valorInicial, i, j);
            }
        }
        
        int izqEstado;
        int derEstado;
        int atrasEstado;
        
        String referencia;
        
        // Coloco la referencia a los estados en la tabla
        for (int i=0; i<CANT_ESTADOS; i++){
            izqEstado = i % 3;
            derEstado = (i / 3) % 3;
            atrasEstado = (i / 9) % 3;
            
            referencia = "" + atrasEstado + " - " + derEstado + " - " + izqEstado;
            
            qTable.setValueAt(referencia, i, CANT_ACCIONES);
        }
    }

    //Ejecutar accion en el servidor
    //OJO Esto puede cambiarse dejando dos parametros indicando las velocidades de las ruedas y sacando el switch
    public String ejecutarAccion(int accion, Socket socket) {
        String respuesta = "NO MIRAR!!";
        try {
            switch (accion) {
                case ACCION_IZQ_M30_DER_M30: {
                    writeToAndReadFromSocket(socket, "2,-30,-30" + "\0");
                    break;
                }
                case ACCION_IZQ_M30_DER_35: {
                    writeToAndReadFromSocket(socket, "2,-30,35" + "\0");
                    break;
                }
                case ACCION_IZQ_M30_DER_50: {
                    writeToAndReadFromSocket(socket, "2,-30,50" + "\0");
                    break;
                }
                case ACCION_IZQ_35_DER_M30: {
                    writeToAndReadFromSocket(socket, "2,35,-30" + "\0");
                    break;
                }
                case ACCION_IZQ_35_DER_35: {
                    writeToAndReadFromSocket(socket, "2,35,35" + "\0");
                    break;
                }
                case ACCION_IZQ_35_DER_50: {
                    writeToAndReadFromSocket(socket, "2,35,50" + "\0");
                    break;
                }
                case ACCION_IZQ_50_DER_M30: {
                    writeToAndReadFromSocket(socket, "2,50,-30" + "\0");
                    break;
                }
                case ACCION_IZQ_50_DER_35: {
                    writeToAndReadFromSocket(socket, "2,50,35" + "\0");
                    break;
                }
                case ACCION_IZQ_50_DER_50: {
                    writeToAndReadFromSocket(socket, "2,50,50" + "\0");
                    break;
                }
                case ACCION_LEER_SENSORES: {
                    respuesta = writeToAndReadFromSocket(socket, "24" + "\0");
                    break;
                }
                default: {
                    System.out.println("ACCION INVALIDA");
                }
            }
        } catch (Exception ex) {
            Logger.getLogger(QLearning.class.getName()).log(Level.SEVERE, null, ex);
        }
        return respuesta;
    }

    //Recupera la posicion de estado actual
    public int getEstado(Socket socket) {
        String valorSensores;
        String[] arr;
        int[] arr_int = new int[8];
        int pos_estado = 0;
        auxiliar2 = 0;

        //Consultar valor de sensores y control de falta de respuesta
        valorSensores = this.ejecutarAccion(ACCION_LEER_SENSORES, socket);
        System.out.println("Valores Sensores es:: " + valorSensores);
        arr = valorSensores.split(";");

        for (int j = 0; j < 8; j++) {
            System.out.println("Arr en " + j + "ES::" + arr[j]);
            arr_int[j] = Integer.parseInt(arr[j]);
            auxiliar2 = auxiliar2 +  arr_int[j] * pesos[j];
        }
        
        double promedioIzq = 0.0;
        double promedioDer = 0.0;
        double promedioAtras = 0.0;
        
        for (int aux=0;aux<3;aux++){
            promedioIzq += arr_int[aux];
        }
        promedioIzq = promedioIzq / 3;
        
        for (int aux=3;aux<6;aux++){
            promedioDer += arr_int[aux];
        }
        promedioDer = promedioDer / 3;
        
        for (int aux=6;aux<8;aux++){
            promedioAtras += arr_int[aux];
        }
        promedioAtras = promedioAtras / 2;
        
        
        
        int[] valoresDiscretizados = new int[3];
        
        if (promedioIzq < VALOR_APROXIMACION){
            valoresDiscretizados[0] = 0;
        }
        else{
            if (promedioIzq < VALOR_CHOQUE){
                valoresDiscretizados[0] = 1;
            }
            else{
                valoresDiscretizados[0] = 2;
            }
        }

        if (promedioDer < VALOR_APROXIMACION){
            valoresDiscretizados[1] = 0;
        }
        else{
            if (promedioDer < VALOR_CHOQUE){
                valoresDiscretizados[1] = 1;
            }
            else{
                valoresDiscretizados[1] = 2;
            }
        }
        
        if (promedioAtras < VALOR_APROXIMACION){
            valoresDiscretizados[2] = 0;
        }
        else{
            if (promedioAtras < VALOR_CHOQUE){
                valoresDiscretizados[2] = 1;
            }
            else{
                valoresDiscretizados[2] = 2;
            }
        }        
        
        
        //Calcula la posicion de estado en base al valor de los sensores discretizados
        for (int i = 0; i < 3; i++) {
            pos_estado += valoresDiscretizados[i] * (Math.pow(3.0, i));
        }

        return pos_estado;
    }

    private int seleccionarAccion(int estado) {

        int pos_accion = 0;
        double max_val = tabla_q[estado][0];

        for (int i = 1; i < CANT_ACCIONES; i++) {
            if (tabla_q[estado][i] > max_val) {
                max_val = tabla_q[estado][i];
                pos_accion = i;
            }
        }

        //Explore
        if (Math.random() < epsilon) {
            pos_accion = (pos_accion + (int)(Math.random() * CANT_ACCIONES)) % CANT_ACCIONES;
        }
        return pos_accion;
    }

    public double getRecompensa(int pos_estado, int nuevo_pos_estado) {

        System.out.println("auxiliar 1 : "+ auxiliar + "-----auxiliar2  "+ auxiliar2);

        if(auxiliar  > auxiliar2 + 300){
            
            auxiliar = auxiliar2;
            //System.out.println("Entro sleeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeep");
            //try{
            //    sleep(1000);
            //}catch(Exception ex){

            //}
            return 1;
        }
        else{
            if((Math.abs(auxiliar - auxiliar2) < 250)|| (auxiliar == 0)){
                auxiliar = auxiliar2;
                return 0;
            }

            auxiliar = auxiliar2;
            return -1;
        }




//        int izqEstado, derEstado, atrasEstado;
//        int izqNuevoEstado, derNuevoEstado, atrasNuevoEstado;
//        
//        //// 
//        izqEstado = pos_estado % 3;
//        derEstado = (pos_estado / 3) % 3;
//        atrasEstado = (pos_estado / 9) % 3;
//  
//        izqNuevoEstado = nuevo_pos_estado % 3;
//        derNuevoEstado = (nuevo_pos_estado / 3) % 3;
//        atrasNuevoEstado = (nuevo_pos_estado / 9) % 3;        
//        
//        
//        if ((izqEstado == 0) && (derEstado == 0) && (atrasEstado == 0)) {
//            if ((izqNuevoEstado == 2) || (derNuevoEstado == 2) || (atrasNuevoEstado == 2)) {
//                return -1;
//            } else {
//                return 0;
//            }
//        } else {
//            if (((izqEstado == 1) || (derEstado == 1) || (atrasEstado == 1)) && ((izqEstado != 2) && (derEstado != 2) && (atrasEstado != 2))) {
//                if ((izqNuevoEstado == 2) || (derNuevoEstado == 2) || (atrasNuevoEstado == 2)) {
//                    return -1;
//                } else {
//                    if ((izqEstado == 0) && (derEstado == 0) && (atrasEstado == 0)){
//                        return 1;
//                    }
//                    else{
//                        return 0;
//                    }
//                }
//            } else {
//                if ((izqNuevoEstado == 2) || (derNuevoEstado == 2) || (atrasNuevoEstado == 2)){
//                    return -1;
//                }
//                else{
//                    return 1;
//                }
//            }
//        }
    }

    private double getMaxQ(int estado) {
        double max_val = tabla_q[estado][0];

        for (int i = 1; i < CANT_ACCIONES; i++) {
            if (tabla_q[estado][i] > max_val) {
                max_val = tabla_q[estado][i];
            }
        }
        return max_val;
    }

    private String writeToAndReadFromSocket(Socket socket, String writeTo) throws Exception {
        try {
            // write text to the socket
            BufferedWriter bufferedWriter = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()));
            bufferedWriter.write(writeTo);
            bufferedWriter.flush();

            // read text from the socket
            BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(socket.getInputStream()));
            StringBuilder sb = new StringBuilder();
            String str;
            while ((str = bufferedReader.readLine()) != null) {
                System.out.println("STR::" + str);
                sb.append(str);
            }

            // close the reader, and return the results as a String
            bufferedReader.close();
            return sb.toString();
        } catch (IOException e) {
            e.printStackTrace();
            throw e;
        }
    }

    /**
     * Open a socket connection to the given server on the given port. This
     * method currently sets the socket timeout value to 10 seconds. (A second
     * version of this method could allow the user to specify this timeout.)
     */
    private Socket openSocket(String server, int port) throws Exception {
        Socket socket;

        // create a socket with a timeout
        try {
            InetAddress inteAddress = InetAddress.getByName(server);
            SocketAddress socketAddress = new InetSocketAddress(inteAddress, port);

            // create a socket
            socket = new Socket();

            // this method will block no more than timeout ms.
            int timeoutInMs = 10 * 1000;   // 10 seconds
            socket.connect(socketAddress, timeoutInMs);

            return socket;
        } catch (SocketTimeoutException ste) {
            System.err.println("Timed out waiting for the socket.");
            ste.printStackTrace();
            throw ste;
        }
    }
    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JLabel jLabel1;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JPanel panelPrincipal;
    private javax.swing.JTable qTable;
    private javax.swing.JLabel qTableLabel;
    // End of variables declaration//GEN-END:variables
}
